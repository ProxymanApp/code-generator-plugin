// Generated by CoffeeScript 1.12.7
const Mustache = require("mustache");

const addslashes = function (str) {
  return ("" + str).replace(/[\\"]/g, "\\$&");
};

const urlTransfrom = function (request) {
  return {
    fullpath: request.url,
    has_https_scheme: request.url.indexOf("https://") === 0,
  };
};

const headersTransform = function (request) {
  var header_name, header_value, headers;
  headers = request.headers;
  return {
    has_headers: Object.keys(headers).length > 0,
    header_list: (function () {
      var results;
      results = [];
      for (header_name in headers) {
        header_value = headers[header_name];
        results.push({
          header_name: addslashes(header_name),
          header_value: addslashes(header_value),
        });
      }
      return results;
    })(),
  };
};

const bodyTransform = function (request) {
  var json_body, multipart_body, name, raw_body, url_encoded_body, value;
  json_body = request.jsonBody;
  if (json_body) {
    return {
      has_json_body: true,
      json_body_object: json_body_object(json_body, 2),
    };
  }
  url_encoded_body = request.urlEncodedBody;
  if (url_encoded_body) {
    return {
      has_url_encoded_body: true,
      url_encoded_body: (function () {
        var results;
        results = [];
        for (name in url_encoded_body) {
          value = url_encoded_body[name];
          results.push({
            name: addslashes(name),
            value: addslashes(value),
          });
        }
        return results;
      })(),
    };
  }
  multipart_body = request.multipartBody;
  if (multipart_body) {
    return {
      has_multipart_body: true,
      multipart_body: (function () {
        var results;
        results = [];
        for (name in multipart_body) {
          value = multipart_body[name];
          results.push({
            name: addslashes(name),
            value: addslashes(value),
          });
        }
        return results;
      })(),
    };
  }
  raw_body = request.body;
  if (raw_body) {
    if (raw_body.length < 5000) {
      return {
        has_raw_body: true,
        raw_body: addslashes(raw_body),
      };
    } else {
      return {
        has_long_body: true,
      };
    }
  }
};

const json_body_object = function (object, indent) {
  var indent_str, indent_str_children, key, s, value;
  if (indent == null) {
    indent = 0;
  }
  if (object === null) {
    s = "nil";
  } else if (typeof object === "string") {
    s = '"' + addslashes(object) + '"';
  } else if (typeof object === "number") {
    s = "" + object;
  } else if (typeof object === "boolean") {
    s = "" + (object ? "true" : "false");
  } else if (typeof object === "object") {
    indent_str = Array(indent + 1).join("    ");
    indent_str_children = Array(indent + 2).join("    ");
    if (object.length != null) {
      s =
        "[\n" +
        function () {
          var i, len, results;
          results = [];
          for (i = 0, len = object.length; i < len; i++) {
            value = object[i];
            results.push(
              "" +
                indent_str_children +
                json_body_object(value, indent + 1)
            );
          }
          return results;
        }
          .call(this)
          .join(",\n") +
        ("\n" + indent_str + "]");
    } else {
      s =
        "{\n" +
        function () {
          var results;
          results = [];
          for (key in object) {
            value = object[key];
            results.push(
              indent_str_children +
                '"' +
                addslashes(key) +
                '" : ' +
                json_body_object(value, indent + 1)
            );
          }
          return results;
        }
          .call(this)
          .join(",\n") +
        ("\n" + indent_str + "}");
    }
  }
  return s;
};

exports.generate = function (request) {
  const view = {
    request: request,
    method: request.method.toLowerCase(),
    url: urlTransfrom(request),
    headers: headersTransform(request),
    body: bodyTransform(request),
  };
  return Mustache.render(codeTemplate, view);
};

// Inlcude a template because we could not build require("fs") in webpack

const codeTemplate = `// import http package
import 'package:http/http.dart' as http;

// {{{request.name}}} ({{{request.method}}})
send_request() async {

    var url = "{{{request.url}}}";
    
    // Create request
    var request = http.Request('{{{request.method}}}', Uri.parse(url));

    {{#headers.has_headers}}
    // Add headers
    headers={
        {{#headers.header_list}}
        "{{{header_name}}}": "{{{header_value}}}",
        {{/headers.header_list}}
    },
    request.headers.addAll(headers);
    {{/headers.has_headers}}

    {{#body.has_json_body}}
    // Set body
    request.body = json.encode({{{body.json_body_object}}});
    {{/body.has_json_body}}
    
    {{#body.has_raw_body}}
    // Set body
    request.body = json.encode({{{body.json_body_object}}});
    {{/body.has_raw_body}}

    {{#body.has_long_body}}
    // Set body
    data=""  # set your body string
    {{/body.has_long_body}}

    {{#body.has_url_encoded_body}}
    // Set body
    request.bodyFields = {
    {{#body.url_encoded_body}}
    "{{{name}}}": "{{{value}}}",
    {{/body.url_encoded_body}},
    };
    {{/body.has_url_encoded_body}}

    {{#body.has_multipart_body}}
    // Set body
    files={
    {{#body.multipart_body}}
        "{{{name}}}": "{{{value}}}",
    {{/body.multipart_body}}
    },
    {{/body.has_multipart_body}}

    // Fetch Request
    http.StreamedResponse response = await request.send();

    if (response.statusCode == 200) {
        debugPrint(await response.stream.bytesToString());
    }
    else {
        debugPrint(response.reasonPhrase);
    }
}
`;
