// Generated by CoffeeScript 2.5.1
const Mustache = require("mustache");
const URI = require("URIjs");

const addslashes = function (str) {
  return `${str}`.replace(/[\\"]/g, "\\$&");
};

const urlTransform = function (request) {
  var name, url_params, url_params_object, value;
  url_params_object = (function () {
    var _uri;
    _uri = URI(request.url);
    return _uri.search(true);
  })();
  url_params = (function () {
    var results;
    results = [];
    for (name in url_params_object) {
      value = url_params_object[name];
      results.push({
        name: addslashes(name),
        value: addslashes(value),
      });
    }
    return results;
  })();
  return {
    base: addslashes(
      (function () {
        var _uri;
        _uri = URI(request.url);
        _uri.search("");
        return _uri;
      })()
    ),
    params: url_params,
    has_params: url_params.length > 0,
  };
};

const headersTransform = function (request) {
  var header_name, header_value, headers;
  headers = request.headers;
  if (request.httpBasicAuth) {
    delete headers["Authorization"];
  }
  return {
    has_headers: Object.keys(headers).length > 0,
    header_list: (function () {
      var results;
      results = [];
      for (header_name in headers) {
        header_value = headers[header_name];
        results.push({
          header_name: addslashes(header_name),
          header_value: addslashes(header_value),
        });
      }
      return results;
    })(),
  };
};

const bodyTransform = function (request) {
  var has_tabs_or_new_lines,
    json_body,
    multipart_body,
    name,
    raw_body,
    url_encoded_body,
    value;
  json_body = request.jsonBody;
  if (json_body && !json_body.length) {
    return {
      has_form_encoded: false,
      has_json_encoded: true,
      has_json_body: true,
      json_body_object: json_body_object(json_body),
    };
  }
  url_encoded_body = request.urlEncodedBody;
  if (url_encoded_body) {
    return {
      has_form_encoded: true,
      has_json_encoded: false,
      has_url_encoded_body: true,
      url_encoded_body: (function () {
        var results;
        results = [];
        for (name in url_encoded_body) {
          value = url_encoded_body[name];
          results.push({
            name: addslashes(name),
            value: addslashes(value),
          });
        }
        return results;
      })(),
    };
  }
  multipart_body = request.multipartBody;
  if (multipart_body) {
    return {
      has_form_encoded: true,
      has_json_encoded: false,
      has_multipart_body: true,
      multipart_body: (function () {
        var results;
        results = [];
        for (name in multipart_body) {
          value = multipart_body[name];
          results.push({
            name: addslashes(name),
            value: addslashes(value),
          });
        }
        return results;
      })(),
    };
  }
  raw_body = request.body;
  if (raw_body) {
    if (raw_body.length < 5000) {
      has_tabs_or_new_lines = null !== /\r|\n|\t/.exec(raw_body);
      return {
        has_form_encoded: true,
        has_json_encoded: false,
        has_raw_body_with_tabs_or_new_lines: has_tabs_or_new_lines,
        has_raw_body_without_tabs_or_new_lines: !has_tabs_or_new_lines,
        raw_body: addslashes(raw_body),
      };
    } else {
      return {
        has_form_encoded: true,
        has_json_encoded: false,
        has_long_body: true,
      };
    }
  }
};

const json_body_object = function (object) {
  var key, s, value;
  if (object === null || !object || typeof object === "undefined") {
    s = "null";
  } else if (typeof object === "string") {
    s = `\"${addslashes(object)}\"`;
  } else if (typeof object === "number") {
    s = `${object}`;
  } else if (typeof object === "boolean") {
    s = `${object ? "true" : "false"}`;
  } else {
    if (object.length != null) {
      s = `    \"${addslashes(JSON.stringify(object))}\"`;
    } else {
      s = "";
      for (key in object) {
        value = object[key];
        if (s.length > 0) {
          s += " \\\n";
        }
        if (typeof value === "string") {
          s += `    ${addslashes(key)}=\"${addslashes(value)}\"`;
        } else if (typeof value === "object" && value !== null) {
          s += `    ${addslashes(key)}:=\"${addslashes(
            JSON.stringify(value, null, "  ")
          )}\"`;
        } else {
          s += `    ${addslashes(key)}:=${addslashes(value)}`;
        }
      }
    }
  }
  return s;
};

const strip_last_backslash = function (string) {
  var i, j, lines, ref;
  // Remove the last backslash on the last non-empty line
  // We do that programatically as it's difficult to know the "last line"
  // in Mustache templates
  lines = string.split("\n");
  for (
    i = j = ref = lines.length - 1;
    ref <= 0 ? j <= 0 : j >= 0;
    i = ref <= 0 ? ++j : --j
  ) {
    lines[i] = lines[i].replace(/\s*\\\s*$/, "");
    if (!lines[i].match(/^\s*$/)) {
      break;
    }
  }
  return lines.join("\n");
};

exports.generate = function (request) {
  var rendered_code, view;
  const url = urlTransform(request);
  view = {
    request: request,
    method: request.method.toUpperCase(),
    url: url,
    headers: headersTransform(request),
    basicAuth: request.httpBasicAuth,
    body: bodyTransform(request),
    headline: `${request.method.toUpperCase()} ${url.base}`,
    version: metadata.version
  };
  rendered_code = Mustache.render(codeTemplate, view);
  return strip_last_backslash(rendered_code);
};

const metadata = {
  name: "HTTPie",
  fileExtension: "sh",
  identifier: "com.proxyman.plugin.httpie",
  author: "Paw and Proxyman",
  version: "1.0.0",
};

// Inlcude a template because we could not build require("fs") in webpack

const codeTemplate =
`{{#body.has_multipart_body}}
# note: HTTPie will post as form url-encoded if no file is specified
{{/body.has_multipart_body}}
{{! ----- }}
http{{#body.has_form_encoded}} --form{{/body.has_form_encoded}}{{#body.has_json_encoded}} --json{{/body.has_json_encoded}} {{{request.method}}} '{{{request.url}}}' \\
{{! ----- }}
{{#headers.has_headers}}
{{#headers.header_list}}
    '{{{header_name}}}':'{{{header_value}}}' \\
{{/headers.header_list}}
{{/headers.has_headers}}
{{! ----- }}
{{#basicAuth}}
    --auth {{{basicAuth.username}}}:{{{basicAuth.password}}} \\
{{/basicAuth}}
{{! ----- }}
{{#body.has_url_encoded_body}}
{{#body.url_encoded_body}}
    '{{{name}}}'='{{{value}}}' \\
{{/body.url_encoded_body}}
{{/body.has_url_encoded_body}}
{{! ----- }}
{{#body.has_raw_body_with_tabs_or_new_lines}}
    'data'=$'{{{body.raw_body}}}' \\
{{/body.has_raw_body_with_tabs_or_new_lines}}
{{! ----- }}
{{#body.has_raw_body_without_tabs_or_new_lines}}
    'data'='{{{body.raw_body}}}' \\
{{/body.has_raw_body_without_tabs_or_new_lines}}
{{! ----- }}
{{#body.has_long_body}}
    'data'='set your body string' \\
{{/body.has_long_body}}
{{! Content type is wrong for multipart cause we are not passing a file so far }}
{{! https://github.com/jakubroztocil/httpie#request-items }}
{{#body.has_multipart_body}}
{{#body.multipart_body}}
    '{{{name}}}'='{{{value}}}' \\
{{/body.multipart_body}}
{{/body.has_multipart_body}}
{{! ----- }}
{{#body.has_json_body}}
{{{body.json_body_object}}}
{{/body.has_json_body}}
`;